require('dotenv').config()
import TelegramBot from 'node-telegram-bot-api';
import db from './database';
import { addReferral, getReferralStats } from './database';
// import { getDailyTasks, completeTask } from './tasks';

const token = process.env.BOT_TOKEN as string;
const adminBotToken = process.env.ADMIN_BOT_TOKEN as string;
const adminChatId = process.env.ADMIN_CHAT_ID as string;

const bot = new TelegramBot(token, { polling: true });
const adminBot = new TelegramBot(adminBotToken, { polling: true });

// Track video watching status
const watchingUsers = new Map<number, { taskId: number, startTime: number }>();
interface Task {
    id: number;
    title: string;
    video_url: string;
} 
// Available commands for users
const userCommands = [
    { command: 'start', description: 'Start the bot and register' },
    { command: 'daily', description: 'Get daily tasks' },
    { command: 'balance', description: 'Check your points balance' },
    { command: 'withdraw', description: 'Request withdrawal' },
    { command: 'help', description: 'Show available commands' },
    { command: 'settings', description: 'âš™ï¸ Configure payment settings' },
    { command: 'referrals', description: 'ğŸ‘¥ View your referral statistics' }
];

// Available commands for admin
const adminCommands = [
    { command: 'broadcast', description: 'Send message to all users' },
    { command: 'stats', description: 'View total users and statistics' },
    { command: 'addtask', description: 'Add new task' },
    { command: 'deletetask', description: 'Delete existing task' },
    { command: 'tasks', description: 'View all tasks' }
];

// Set commands for both bots
bot.setMyCommands(userCommands);
adminBot.setMyCommands(adminCommands);

console.log('Bot is running');

async function checkUserMembership(chatId: number): Promise<boolean> {
    try {
        const isMember1 = await checkChannelMembership(chatId, 'tasktest11');
        const isMember2 = await checkChannelMembership(chatId, 'tasktest11');
        console.log(isMember1, isMember2,chatId);
        return isMember1 && isMember2;
    } catch (error) {
        console.error('Error checking user membership:', error);
        return false;
    }
}

bot.onText(/\/start/, async (msg) => {
    const chatId = msg.chat.id;

    // Check user membership
    if (!await checkUserMembership(chatId)) {
        bot.sendMessage(chatId, 
            'âš ï¸ You must join the following channels to use the bot:\n' +
            '1. [Channel 1](https://t.me/tasktest11)\n' +
            '2. [Channel 2](https://t.me/tasktest11)\n\n' +
            'Please join the channels and then click /start again.', {
            parse_mode: 'Markdown'
        });
        return;
    }

    const startPayload = msg.text?.split(' ')[1] || ''; // Add optional chaining and default value

    // Check if user is already registered
    db.get(`SELECT is_registered FROM users WHERE telegram_id = ?`, [chatId], async (err, row: any) => {
        if (row && row.is_registered) {
            bot.sendMessage(chatId, 
                'ğŸ‰ *Welcome Back!*\n\n' +
                'âœ¨ You are already registered!\n' +
                'ğŸ“ Use /help to see available commands.', {
                parse_mode: 'Markdown',
                reply_markup: {
                    remove_keyboard: true
                }
            });
        } else {
            // Handle referral if exists
            if (startPayload && startPayload !== chatId.toString()) {
                const success = await addReferral(startPayload, chatId.toString());
                if (success) {
                    bot.sendMessage(startPayload, 
                        'ğŸ‰ *Congratulations!*\n\n' +
                        'ğŸ‘¤ Someone joined using your referral link!\n' +
                        'ğŸ’° You earned 50 points!', {
                        parse_mode: 'Markdown'
                    });
                }
            }

            // Continue with normal registration
            bot.sendMessage(chatId, 'Welcome to the bot! Please share your phone number to register.', {
                reply_markup: {
                    keyboard: [[
                        {
                            text: 'Share Phone Number',
                            request_contact: true
                        }
                    ]],
                    resize_keyboard: true,
                    one_time_keyboard: true
                }
            });
        }
    });
});

// Function to check if a user is a member of a channel
async function checkChannelMembership(userId: number, channelUsername: string): Promise<boolean> {
    try {
        const member = await bot.getChatMember(`@${channelUsername}`, userId);
        console.log(`User ${userId} in ${channelUsername}:`, member);
        return ['member', 'administrator', 'creator'].includes(member.status);
    } catch (error) {
        console.error(`Error checking membership for ${channelUsername}:`, error);
        return false;
    }
}


bot.on('contact', (msg) => {
    const chatId = msg.chat.id;

    if (msg.contact) {
        const phoneNumber = msg.contact.phone_number;

        db.run(`INSERT OR IGNORE INTO users (telegram_id, phone_number, is_registered) VALUES (?, ?, 1)`, 
            [chatId, phoneNumber], (err) => {
            if (err) {
                bot.sendMessage(chatId, 'Error registering user.');
            } else {
                bot.sendMessage(chatId, 'Thank you! You are registered. Use /help to see available commands.', {
                    reply_markup: {
                        remove_keyboard: true
                    }
                });
            }
        });
    }
});

bot.onText(/\/balance/, async (msg) => {
    const chatId = msg.chat.id;

    // Check user membership
    if (!await checkUserMembership(chatId)) {
        bot.sendMessage(chatId, 
            'âš ï¸ You must join the following channels to use the bot:\n' +
            '1. [Channel 1](https://t.me/tasktest11)\n' +
            '2. [Channel 2](https://t.me/tasktest12)\n\n' +
            'Please join the channels and then try again.', {
            parse_mode: 'Markdown'
        });
        return;
    }

    db.get(`SELECT points FROM users WHERE telegram_id = ?`, [chatId], (err, row: any) => {
        if (row) {
            bot.sendMessage(chatId, `Your current balance is: ${row.points} points`);
        } else {
            bot.sendMessage(chatId, 'Please register first using /start');
        }
    });
});

bot.onText(/\/withdraw/, async (msg) => {
    const chatId = msg.chat.id;

    // Check user membership
    if (!await checkUserMembership(chatId)) {
        bot.sendMessage(chatId, 
            'âš ï¸ You must join the following channels to use the bot:\n' +
            '1. [Channel 1](https://t.me/tasktest11)\n' +
            '2. [Channel 2](https://t.me/tasktest12)\n\n' +
            'Please join the channels and then try again.', {
            parse_mode: 'Markdown'
        });
        return;
    }

    db.get(`SELECT points, payment_method, payment_detail FROM users WHERE telegram_id = ?`, 
        [chatId], (err, row: any) => {
        if (!row.payment_method || !row.payment_detail) {
            bot.sendMessage(chatId, 
                'âš ï¸ Please set up your payment details first!\n' +
                'Use /settings to configure your payment method.');
            return;
        }

        if (row && row.points >= 30) {
            bot.sendMessage(chatId, 
                'ğŸ’° *Withdrawal Request*\n\n' +
                `Current Balance: ${row.points} points\n` +
                'Please enter the amount of points you want to withdraw:\n' +
                '_(Minimum: 30 points)_', {
                parse_mode: 'Markdown'
            });

            bot.once('message', async (pointsMsg) => {
                const pointsToWithdraw = parseInt(pointsMsg.text || '0', 10);
                
                if (isNaN(pointsToWithdraw) || pointsToWithdraw < 30) {
                    bot.sendMessage(chatId, 'âŒ Minimum withdrawal amount is 30 points.');
                    return;
                }
                
                if (pointsToWithdraw > row.points) {
                    bot.sendMessage(chatId, `âŒ You only have ${row.points} points available.`);
                    return;
                }

                db.run(`INSERT INTO withdrawal_requests (user_id, points) VALUES (?, ?)`, 
                    [chatId, pointsToWithdraw], (err) => {
                    if (!err) {
                        bot.sendMessage(chatId, 'âœ… Your withdrawal request has been sent to admin for approval.');
                        // Notify admin
                        adminBot.sendMessage(adminChatId, 
                            `ğŸ†• *New Withdrawal Request*\n\n` +
                            `ğŸ‘¤ User ID: ${chatId}\n` +
                            `ğŸ’° Requested: ${pointsToWithdraw} points\n` +
                            `ğŸ’³ Current Balance: ${row.points} points\n` +
                            `\n*Payment Details:*\n` +
                            `Method: ${row.payment_method.toUpperCase()}\n` +
                            `Details: \`${row.payment_detail}\``, {
                            parse_mode: 'Markdown',
                            reply_markup: {
                                inline_keyboard: [[
                                    { text: 'âœ… Accept', callback_data: `accept_${chatId}` },
                                    { text: 'âŒ Reject', callback_data: `reject_${chatId}` }
                                ]]
                            }
                        });
                    }
                });
            });
        } else {
            bot.sendMessage(chatId, 'âŒ You need at least 30 points to withdraw.');
        }
    });
});

// Admin bot handlers
adminBot.on('callback_query', async (callbackQuery) => {
    const msg = callbackQuery.message;
    const data = callbackQuery.data;

    if (msg && data) {
        const [action, userId] = data.split('_');
        if (action === 'accept') {
            adminBot.sendMessage(msg.chat.id, 'Enter points to withdraw (e.g., "20"):');
            // Store the context for the next message
            adminBot.once('message', async (pointsMsg) => {
                const pointsToWithdraw = parseInt(pointsMsg.text || '0', 10);
                db.run(`UPDATE users SET points = points - ? WHERE telegram_id = ?`, 
                    [pointsToWithdraw, userId], (err) => {
                    if (!err) {
                        bot.sendMessage(userId, `Your withdrawal of ${pointsToWithdraw} points has been approved!`);
                        adminBot.sendMessage(msg.chat.id, 'Withdrawal processed successfully.');
                    }
                });
            });
        } else if (action === 'reject') {
            db.run(`UPDATE withdrawal_requests SET status = 'rejected' WHERE user_id = ?`, 
                [userId], (err) => {
                if (!err) {
                    bot.sendMessage(userId, 'Your withdrawal request has been rejected.');
                    adminBot.sendMessage(msg.chat.id, 'Withdrawal request rejected.');
                }
            });
        }
    }
});

// Help command
bot.onText(/\/help/, (msg) => {
    const chatId = msg.chat.id;
    const helpText = 'ğŸ¤– *Available Commands:*\n\n' + userCommands
        .map(cmd => `/${cmd.command} - ${cmd.description}`)
        .join('\n') + '\n\n' +
        'ğŸ’¡ *Tips:*\n' +
        'â€¢ Complete daily tasks to earn points\n' +
        'â€¢ Watch videos fully to get rewards\n' +
        'â€¢ Refer friends to earn 50 points per referral\n' +
        'â€¢ Withdraw when you reach 30 points';
    
    bot.sendMessage(chatId, helpText, {
        parse_mode: 'Markdown'
    });
});

// Updated daily tasks implementation
bot.onText(/\/daily/, (msg) => {
    const chatId = msg.chat.id;
    db.all(`
        SELECT t.* FROM tasks t
        WHERE NOT EXISTS (
            SELECT 1 FROM completed_tasks ct 
            WHERE ct.task_id = t.id 
            AND ct.user_id = ? 
            AND DATE(ct.completed_at) = DATE('now')
        )
        LIMIT 5
    `, [chatId], (err, tasks: Task[]) => {
        if (err || tasks.length === 0) {
            bot.sendMessage(chatId, 
                'ğŸ“º *No More Tasks*\n\n' +
                'âœ¨ You\'ve completed all tasks for today!\n' +
                'ğŸŒŸ Come back tomorrow for more.', {
                parse_mode: 'Markdown'
            });
            return;
        }

        // bot.sendMessage(chatId, 
        //     'ğŸ“‹ *Daily Tasks Available*\n\n' +
        //     'ğŸ’« Complete these tasks to earn points!\n' +
        //     'â± Each task requires 20 seconds of watching\n' +
        //     'ğŸ¯ Earn 20 points per completed task', {
        //     parse_mode: 'Markdown'
        // });

        tasks.forEach((task) => {
            bot.sendMessage(chatId, 
                `ğŸ“ *Task:* ${task.title}\n\n` +
                `â„¹ï¸ *Instructions:*\n` +
                `1ï¸âƒ£ Click "Watch Video" to start\n` +
                `2ï¸âƒ£ Watch for at least 20 seconds\n` +
                `3ï¸âƒ£ Click "Finish Task" to earn points`, {
                parse_mode: 'Markdown',
                reply_markup: {
                    inline_keyboard: [[
                        { text: 'â–¶ï¸ Watch Video', callback_data: `watch_${task.id}` },
                        { text: 'âœ… Finish Task', callback_data: `finish_${task.id}` }
                    ]]
                }
            });
        });
    });
});

// Handle video watching callbacks
bot.on('callback_query', (callbackQuery) => {
    const msg = callbackQuery.message;
    const data = callbackQuery.data;
    if (!msg || !data) return;

    const userId = msg.chat.id;
    
    if (data.startsWith('watch_')) {
        const taskId = data.split('_')[1];
        const taskIdNum = parseInt(taskId, 10);
        
        // Get video URL from database
        db.get(`SELECT video_url FROM tasks WHERE id = ?`, [taskIdNum], (err, task: any) => {
            if (err || !task) {
                bot.answerCallbackQuery(callbackQuery.id, { 
                    text: 'âŒ Error loading video'
                });
                return;
            }

            // Start watching
            watchingUsers.set(userId, { taskId: taskIdNum, startTime: Date.now() });
            
            bot.answerCallbackQuery(callbackQuery.id, { 
                text: `ğŸ¥ Video Started\n\n` +
                      `ğŸ”— Watch here: ${task.video_url}\n\n` +
                      `â± Watch for at least 20 seconds\n` +
                      `âœ… Click "Finish Task" when done`
            });
            
            // Send the video URL as a separate message
            bot.sendMessage(userId, `ğŸ¥ Watch video here: ${task.video_url}`);
        });
    }
    
    else if (data.startsWith('finish_')) {
        const taskId = data.split('_')[1];
        const taskIdNum = parseInt(taskId, 10);
        const watchingData = watchingUsers.get(userId);
        
        // Check if user has started watching
        if (!watchingData || watchingData.taskId !== taskIdNum) {
            bot.answerCallbackQuery(callbackQuery.id, { 
                text: 'âš ï¸ Please watch the video first!',
                show_alert: true
            });
            return;
        }

        // Check if enough time has passed
        const timeSpent = (Date.now() - watchingData.startTime) / 1000;
        if (timeSpent < 20) {
            bot.answerCallbackQuery(callbackQuery.id, { 
                text: `â³ watch the video and wait ${Math.ceil(20 - timeSpent)} more seconds`,
                show_alert: true
            });
            return;
        }

        // Complete the task
        db.run(`INSERT INTO completed_tasks (user_id, task_id, completed_at) VALUES (?, ?, datetime('now'))`, 
            [userId, taskIdNum], (err) => {
            if (!err) {
                db.run(`UPDATE users SET points = points + 20 WHERE telegram_id = ?`, 
                    [userId], (err) => {
                    if (!err) {
                        bot.editMessageReplyMarkup({
                            inline_keyboard: [[
                                { text: 'âœ… Task Completed', callback_data: 'completed' }
                            ]]
                        }, {
                            chat_id: msg.chat.id,
                            message_id: msg.message_id
                        });
                        bot.sendMessage(msg.chat.id, 
                            'ğŸ‰ *Task Completed!*\n\n' +
                            'ğŸ¯ You earned 20 points!\n' +
                            'ğŸ’° Use /balance to check your earnings\n' +
                            'ğŸ“ Use /daily for more tasks', {
                            parse_mode: 'Markdown'
                        });
                        watchingUsers.delete(userId);
                        bot.answerCallbackQuery(callbackQuery.id, { 
                            text: 'âœ… Task completed successfully!'
                        });
                    }
                });
            } else {
                bot.sendMessage(msg.chat.id, 'âŒ You have already completed this task today.');
                bot.answerCallbackQuery(callbackQuery.id, { 
                    text: 'âŒ Task already completed'
                });
            }
        });
    }
})

// Admin Commands
adminBot.onText(/\/broadcast/, (msg) => {
    if (msg.chat.id.toString() !== adminChatId) return;
    
    adminBot.sendMessage(msg.chat.id, 'Please enter the message you want to broadcast:');
    adminBot.once('message', async (broadcastMsg) => {
        if (!broadcastMsg.text) return;
        
        db.all(`SELECT telegram_id FROM users WHERE is_registered = 1`, [], async (err, users: {telegram_id: string}[]) => {
            if (err) {
                adminBot.sendMessage(msg.chat.id, 'Error fetching users.');
                return;
            }
            
            let successCount = 0;
            let failCount = 0;
            
            for (const user of users) {
                try {
                    await bot.sendMessage(user.telegram_id, broadcastMsg.text!);
                    successCount++;
                } catch {
                    failCount++;
                }
            }
            
            adminBot.sendMessage(msg.chat.id, 
                `Broadcast completed!\nSuccess: ${successCount}\nFailed: ${failCount}`);
        });
    });
});

adminBot.onText(/\/stats/, (msg) => {
    if (msg.chat.id.toString() !== adminChatId) return;
    
    db.get(`
        SELECT 
            COUNT(*) as total_users,
            SUM(CASE WHEN is_registered = 1 THEN 1 ELSE 0 END) as registered_users,
            SUM(points) as total_points
        FROM users
    `, [], (err, stats: any) => {
        if (err) {
            adminBot.sendMessage(msg.chat.id, 'Error fetching statistics.');
            return;
        }
        
        adminBot.sendMessage(msg.chat.id, 
            `ğŸ“Š Bot Statistics\n\n` +
            `Total Users: ${stats.total_users}\n` +
            `Registered Users: ${stats.registered_users}\n` +
            `Total Points Distributed: ${stats.total_points}`
        );
    });
});

adminBot.onText(/\/addtask/, (msg) => {
    if (msg.chat.id.toString() !== adminChatId) return;
    
    adminBot.sendMessage(msg.chat.id, 
        'Please enter task details in the following format:\n' +
        'Title | Video URL\n\n' +
        'Example:\nWatch this video | https://youtube.com/watch?v=123'
    );
    
    adminBot.once('message', (taskMsg) => {
        if (!taskMsg.text) return;
        
        const [title, video_url] = taskMsg.text.split('|').map(s => s.trim());
        
        if (!title || !video_url) {
            adminBot.sendMessage(msg.chat.id, 'Invalid format. Please try again.');
            return;
        }

        // Validate URL format
        try {
            new URL(video_url);
        } catch {
            adminBot.sendMessage(msg.chat.id, 'Invalid video URL. Please try again.');
            return;
        }
        
        if (title.length < 3 || title.length > 100) {
            adminBot.sendMessage(msg.chat.id, 'Title must be between 3 and 100 characters.');
            return;
        }
        
        db.run(`INSERT INTO tasks (title, video_url) VALUES (?, ?)`,
            [title, video_url], (err) => {
            if (err) {
                adminBot.sendMessage(msg.chat.id, 'Error adding task.');
                return;
            }
            adminBot.sendMessage(msg.chat.id, 'Task added successfully!');
        });
    });
});

adminBot.onText(/\/deletetask/, (msg) => {
    if (msg.chat.id.toString() !== adminChatId) return;
    
    db.all(`SELECT id, title FROM tasks`, [], (err, tasks: any[]) => {
        if (err || !tasks.length) {
            adminBot.sendMessage(msg.chat.id, 'No tasks available.');
            return;
        }
        
        const keyboard = tasks.map(task => [{
            text: task.title,
            callback_data: `delete_${task.id}`
        }]);
        
        adminBot.sendMessage(msg.chat.id, 'Select task to delete:', {
            reply_markup: {
                inline_keyboard: keyboard
            }
        });
    });
});

adminBot.onText(/\/tasks/, (msg) => {
    if (msg.chat.id.toString() !== adminChatId) return;
    
    db.all(`SELECT * FROM tasks`, [], (err, tasks: any[]) => {
        if (err || !tasks.length) {
            adminBot.sendMessage(msg.chat.id, 'No tasks available.');
            return;
        }
        
        const tasksList = tasks.map(task => 
            `ID: ${task.id}\nTitle: ${task.title}\nVideo: ${task.video_url}\n`
        ).join('\n');
        
        adminBot.sendMessage(msg.chat.id, `ğŸ“ Available Tasks:\n\n${tasksList}`);
    });
});

// Handle admin task deletion
adminBot.on('callback_query', async (callbackQuery) => {
    const msg = callbackQuery.message;
    const data = callbackQuery.data;
    
    if (!msg || !data || msg.chat.id.toString() !== adminChatId) return;
    
    if (data.startsWith('delete_')) {
        const taskId = parseInt(data.split('_')[1], 10);
        
        db.run(`DELETE FROM tasks WHERE id = ?`, [taskId], (err) => {
            if (err) {
                adminBot.sendMessage(msg.chat.id, 'Error deleting task.');
                return;
            }
            adminBot.editMessageText('Task deleted successfully!', {
                chat_id: msg.chat.id,
                message_id: msg.message_id
            });
        });
    }
});

// Add payment settings handler
bot.onText(/\/settings/, (msg) => {
    const chatId = msg.chat.id;
    bot.sendMessage(chatId, 
        'âš™ï¸ *Payment Settings*\n\n' +
        'Choose payment method:\n' +
        'ğŸ¦ Available options:\n' +
        'â€¢ CBE Bank\n' +
        'â€¢ TeleBirr\n\n' +
        'Select your preferred method:', {
        parse_mode: 'Markdown',
        reply_markup: {
            inline_keyboard: [[
                { text: 'CBE Bank ğŸ¦', callback_data: 'set_cbe' },
                { text: 'TeleBirr ï¿½ï¿½', callback_data: 'set_telbirr' }
            ]]
        }
    });
});

// Handle payment settings
bot.on('callback_query', async (callbackQuery) => {
    const msg = callbackQuery.message;
    const data = callbackQuery.data;
    if (!msg || !data) return;

    if (data.startsWith('set_')) {
        const method = data.split('_')[1];
        const chatId = msg.chat.id;
        
        bot.sendMessage(chatId, 
            `ğŸ“ Please enter your ${method === 'cbe' ? 'CBE Bank account number' : 'TeleBirr phone number'}:`);
        
        bot.once('message', async (detailMsg) => {
            if (!detailMsg.text) return;
            
            db.run(`UPDATE users SET payment_method = ?, payment_detail = ? WHERE telegram_id = ?`,
                [method, detailMsg.text, chatId], (err) => {
                if (!err) {
                    bot.sendMessage(chatId, 'âœ… Payment details updated successfully!');
                } else {
                    bot.sendMessage(chatId, 'âŒ Error updating payment details. Please try again.');
                }
            });
        });
    }
});

// Add referral command handler
bot.onText(/\/referrals/, async (msg) => {
    const chatId = msg.chat.id;
    const stats = await getReferralStats(chatId.toString());

    if (!stats) {
        return bot.sendMessage(chatId, 'âŒ Error fetching referral statistics.');
    }

    const referralLink = `https://t.me/${(await bot.getMe()).username}?start=${chatId}`;

    const message = `
ğŸ¯ *Your Referral Statistics*

ğŸ‘¥ Total Referrals: ${stats.total_referrals}
ğŸ’° Referral Points Earned: ${stats.referral_points}
${stats.referred_by ? 'ğŸ”„ You were referred by someone' : ''}

*How to Refer:*
1. Share your unique referral link
2. Earn 50 points for each new user
3. Your friend also gets bonus points!

ğŸ”— *Your Referral Link:*
\`${referralLink}\`

ğŸ’¡ *Share this link with your friends to earn points!*`;

    bot.sendMessage(chatId, message, {
        parse_mode: 'Markdown',
        reply_markup: {
            inline_keyboard: [[
                { text: 'ğŸ“¤ Share Referral Link', url: `https://t.me/share/url?url=${encodeURIComponent(referralLink)}&text=${encodeURIComponent('Join this amazing bot and earn points! Use my referral link:')}` }
            ]]
        }
    });
});


